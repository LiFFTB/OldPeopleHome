###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               23/Aug/2019  12:13:07
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\roomPwrManSys.c
#    Command line       =  
#        -f C:\Users\VULCAN\AppData\Local\Temp\EWDB98.tmp
#        (E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\roomPwrManSys.c
#        -D ZIGBEEPRO -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D
#        LCD_SUPPORTED=DEBUG -D SAPP_ZSTACK -lC
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List
#        -lA
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List
#        --diag_suppress Pe001,Pa010 -o
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wRouter.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DRTR_NWK) -f
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00800000 -DZDAPP_CONFIG_PAN_ID=0x0057
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\mt\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\List\roomPwrManSys.lst
#    Object file        =  
#        E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\RouterEB\Obj\roomPwrManSys.r51
#
###############################################################################

E:\qq下载文件\ZStack-CC2530-r200\ZStack-CC2530-r200\Projects\SappWsn\Source\roomPwrManSys.c
      1          #include "roomPwrManSys.h"

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1
      2          #include "hal_io.h"
      3          #include <string.h>
      4          #include "hal_adc.h"
      5          #include "hal_assert.h"
      6          #include "hal_board.h"
      7          #include "hal_ccm.h"
      8          #include "hal_defs.h"
      9          #include "hal_drivers.h"
     10          #include "hal_flash.h"
     11          #include "hal_irdec.h"
     12          #include "hal_key.h"
     13          #include "hal_lcd.h"
     14          #include "hal_led.h"
     15          #include "hal_sleep.h"
     16          #include "hal_timer.h"
     17          #include "hal_uart.h"
     18          
     19          /********************************/
     20          /* 协调器代码                   */
     21          /********************************/
     22          #if defined(ZDO_COORDINATOR)
     23          uint8 descPkg[] = {
     24              0x03, DevIRPers, 0
     25          };
     26          
     27          static uint16 nodeNwkAddr[Devmax];
     28          static uint8 nodeEndPoint[Devmax];
     29          
     30          static uint8 irPersStatus = 0;
     31          static uint8 illumStatus = 0;
     32          static uint8 controlStatus = 0;
     33          void roomPwrManSys_StaChgRt(struct ep_info_t *ep);
     34          void roomPwrManSys_StaChgRt(struct ep_info_t *ep)
     35          {
     36              // 寻找人体红外节点 
     37              descPkg[1] = DevIRPers;
     38              SendData(ep->ep, descPkg, 0xFFFF, CONTROL_ENDPOINT, sizeof(descPkg));
     39          }
     40          void roomPwrManSys_IncmRt(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
     41          void roomPwrManSys_IncmRt(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
     42          {
     43              //msg->Data[], msg->DataLength, msg->TransSeqNumber
     44              if((endPoint == CONTROL_ENDPOINT) && (msg->Data[0] == 0x03))
     45              {
     46                  // endPoint: msg->Data[1], rCycle: msg->Data[2]
     47                  // 将上一次寻找的节点地址和端点号保存起来
     48                  nodeNwkAddr[descPkg[1]] = addr;
     49                  nodeEndPoint[descPkg[1]] = msg->Data[1];
     50                  // 准备寻找下一个节点
     51                  descPkg[1] = descPkg[1] + 1;
     52                  // 所有节点是否都已经寻找完毕?
     53                  if(descPkg[1] < Devmax)
     54                      SendData(ep->ep, descPkg, 0xFFFF, CONTROL_ENDPOINT, sizeof(descPkg));
     55              }
     56              else
     57              {
     58                  if(addr == nodeNwkAddr[DevIllum])
     59                  {
     60                      // 接收到光照度传感器数据
     61                      uint16 i = 0;
     62                      memcpy(&i, msg->Data, 2);
     63                      illumStatus = i < 45000;
     64                      HalUARTWrite(HAL_UART_PORT_0, msg->Data, 2);
     65                  }
     66                  else if(addr == nodeNwkAddr[DevIRPers])
     67                  {
     68                      // 接收到人体红外传感器数据
     69                      irPersStatus = !!(msg->Data[0]);
     70                  }
     71                  if(nodeNwkAddr[DevExecuter] != 0xFFFF)
     72                  {
     73                      // 如果执行节点存在
     74                      uint8 ctrl = 0;
     75                      if(irPersStatus && illumStatus)
     76                          ctrl = 0x0f;
     77                      // 如果灯光的当前状态与需要设置的状态不一样则发送数据
     78                      if(controlStatus != ctrl)
     79                          SendData(ep->ep, &ctrl, nodeNwkAddr[DevExecuter], nodeEndPoint[DevExecuter], 1);
     80                      controlStatus = ctrl;
     81                  }
     82              }
     83          }
     84          void roomPwrManSys_ToRt(struct ep_info_t *ep);
     85          void roomPwrManSys_ToRt(struct ep_info_t *ep)
     86          {
     87              // 超时函数,用于检查节点搜索是否完成
     88              // 如果没有完成,则继续搜索
     89              if(descPkg[1] < Devmax)
     90              {
     91                  SendData(ep->ep, descPkg, 0xFFFF, CONTROL_ENDPOINT, sizeof(descPkg));
     92              }
     93          }
     94          void roomPwrManSys_ResAvbRt(struct ep_info_t *ep, RES_TYPE type, void *res);
     95          void roomPwrManSys_ResAvbRt(struct ep_info_t *ep, RES_TYPE type, void *res)
     96          {
     97              switch(type)
     98              {
     99              case ResInit:
    100                  memset(nodeNwkAddr, 0xFF, sizeof(nodeNwkAddr));
    101                  memset(nodeEndPoint, 0xFF, sizeof(nodeEndPoint));
    102                  break;
    103              case ResUserTimer:
    104                  break;
    105              case ResControlPkg:
    106                  break;
    107              }
    108          }
    109          #else
    110          /********************************/
    111          /* 人体红外节点代码             */
    112          /********************************/
    113          #if defined(IRPERS_NODE)
    114          #define SAFTY_IO_GROUP      1
    115          #define SAFTY_IO_BIT        0
    116          void sensorIRPersResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    117          void sensorIRPersResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    118          {
    119              if(type == ResInit)
    120              {
    121                  HalIOSetInput(SAFTY_IO_GROUP, SAFTY_IO_BIT, Pull_Down);
    122                  HalIOIntSet(ep->ep, SAFTY_IO_GROUP, SAFTY_IO_BIT, IOInt_Rising, 0);
    123              }
    124              //IO端口中断触发，中断源检测
    125              if(type == ResIOInt)
    126              {
    127                  uint8 IRPersValue = 1;
    128                  SendData(ep->ep, &IRPersValue, 0x0000, TRANSFER_ENDPOINT, sizeof(IRPersValue));
    129              }
    130          }
    131          void sensorIRPersTimeout(struct ep_info_t *ep);
    132          void sensorIRPersTimeout(struct ep_info_t *ep)
    133          {
    134              uint8 value = HalIOGetLevel(SAFTY_IO_GROUP, SAFTY_IO_BIT);
    135              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    136          }
    137          #endif
    138          /********************************/
    139          /* 光照度节点代码               */
    140          /********************************/
    141          #if defined(ILLUM_NODE)
    142          void sensorILLumTimeout(struct ep_info_t *ep);
    143          void sensorILLumTimeout(struct ep_info_t *ep)
    144          {
    145              uint16 LightValue = 256 - (HalAdcRead(0, HAL_ADC_RESOLUTION_14) >> 3);
    146              // 将AD值变换为光照度的100倍
    147              LightValue = LightValue * 39;// * 10000 / 256;
    148              SendData(ep->ep, &LightValue, 0x0000, TRANSFER_ENDPOINT, sizeof(LightValue));
    149          }
    150          #endif
    151          /********************************/
    152          /* 执行节点代码                 */
    153          /********************************/
    154          #if defined(EXECUTER_NODE)
    155          #define ControlInit()   do { HalIOSetOutput(1,4);HalIOSetOutput(1,5);HalIOSetOutput(1,6);HalIOSetOutput(1,7);Control(0); } while(0)
    156          #define Control(mask)   do { HalIOSetLevel(1,4,mask&0x01);HalIOSetLevel(1,5,mask&0x02);HalIOSetLevel(1,6,mask&0x04);HalIOSetLevel(1,7,mask&0x08); } while(0)
    157          void OutputExecuteBResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    158          void OutputExecuteBResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
   \                     OutputExecuteBResAvailable:
    159          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    160              if(type == ResInit)
   \   000007   7401         MOV       A,#0x1
   \   000009   6E           XRL       A,R6
   \   00000A   7040         JNZ       ??OutputExecuteBResAvailable_0
    161                  ControlInit();
   \   00000C                ; Setup parameters for call to function HalIOSetOutput
   \   00000C   7A04         MOV       R2,#0x4
   \   00000E   7901         MOV       R1,#0x1
   \   000010   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000013                ; Setup parameters for call to function HalIOSetOutput
   \   000013   7A05         MOV       R2,#0x5
   \   000015   7901         MOV       R1,#0x1
   \   000017   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   00001A                ; Setup parameters for call to function HalIOSetOutput
   \   00001A   7A06         MOV       R2,#0x6
   \   00001C   7901         MOV       R1,#0x1
   \   00001E   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000021                ; Setup parameters for call to function HalIOSetOutput
   \   000021   7A07         MOV       R2,#0x7
   \   000023   7901         MOV       R1,#0x1
   \   000025   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000028                ; Setup parameters for call to function HalIOSetLevel
   \   000028   7B00         MOV       R3,#0x0
   \   00002A   7A04         MOV       R2,#0x4
   \   00002C   7901         MOV       R1,#0x1
   \   00002E   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000031                ; Setup parameters for call to function HalIOSetLevel
   \   000031   7B00         MOV       R3,#0x0
   \   000033   7A05         MOV       R2,#0x5
   \   000035   7901         MOV       R1,#0x1
   \   000037   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   00003A                ; Setup parameters for call to function HalIOSetLevel
   \   00003A   7B00         MOV       R3,#0x0
   \   00003C   7A06         MOV       R2,#0x6
   \   00003E   7901         MOV       R1,#0x1
   \   000040   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000043                ; Setup parameters for call to function HalIOSetLevel
   \   000043   7B00         MOV       R3,#0x0
   \   000045   7A07         MOV       R2,#0x7
   \   000047   7901         MOV       R1,#0x1
   \   000049   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
    162          }
   \                     ??OutputExecuteBResAvailable_0:
   \   00004C                REQUIRE ?Subroutine0
   \   00004C                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    163          void outputExecuteB(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    164          void outputExecuteB(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
   \                     outputExecuteB:
    165          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   740B         MOV       A,#0xb
   \   00000B   12....       LCALL     ?XSTACK_DISP0_8
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   F8           MOV       R0,A
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F9           MOV       R1,A
    166              //msg->Data[], msg->DataLength, msg->TransSeqNumber
    167              Control(msg->Data[0]);
   \   000013   E8           MOV       A,R0
   \   000014   2403         ADD       A,#0x3
   \   000016   FE           MOV       R6,A
   \   000017   E4           CLR       A
   \   000018   39           ADDC      A,R1
   \   000019   FF           MOV       R7,A
   \   00001A                ; Setup parameters for call to function HalIOSetLevel
   \   00001A   8E82         MOV       DPL,R6
   \   00001C   F583         MOV       DPH,A
   \   00001E   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000021   A2E0         MOV       C,0xE0 /* A   */.0
   \   000023   E4           CLR       A
   \   000024   33           RLC       A
   \   000025   FB           MOV       R3,A
   \   000026   7A04         MOV       R2,#0x4
   \   000028   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00002B   5402         ANL       A,#0x2
   \   00002D   FB           MOV       R3,A
   \   00002E   7A05         MOV       R2,#0x5
   \   000030   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000033   5404         ANL       A,#0x4
   \   000035   FB           MOV       R3,A
   \   000036   7A06         MOV       R2,#0x6
   \   000038   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00003B   5408         ANL       A,#0x8
   \   00003D   FB           MOV       R3,A
   \   00003E   7A07         MOV       R2,#0x7
   \   000040   7901         MOV       R1,#0x1
   \   000042   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
    168              SendData(ep->ep, &msg->Data[0], 0x0000, TRANSFER_ENDPOINT, 1);
   \   000045                ; Setup parameters for call to function SendData
   \   000045   75..01       MOV       ?V2,#0x1
   \   000048   78..         MOV       R0,#?V2
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004D   78..         MOV       R0,#?V2
   \   00004F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000052   7C00         MOV       R4,#0x0
   \   000054   7D00         MOV       R5,#0x0
   \   000056   8E82         MOV       DPL,R6
   \   000058   8F83         MOV       DPH,R7
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   FA           MOV       R2,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   FB           MOV       R3,A
   \   00005F   E5..         MOV       A,?V0
   \   000061   240B         ADD       A,#0xb
   \   000063   F582         MOV       DPL,A
   \   000065   E4           CLR       A
   \   000066   35..         ADDC      A,?V1
   \   000068   F583         MOV       DPH,A
   \   00006A   E0           MOVX      A,@DPTR
   \   00006B   F9           MOV       R1,A
   \   00006C   12....       LCALL     `??SendData::?relay`; Banked call to: SendData
   \   00006F   7402         MOV       A,#0x2
   \   000071   12....       LCALL     ?DEALLOC_XSTACK8
    169          }
   \   000074   7F03         MOV       R7,#0x3
   \   000076   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7901         MOV       R1,#0x1
   \   000002   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005   8E82         MOV       DPL,R6
   \   000007   8F83         MOV       DPH,R7
   \   000009   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   E0           MOVX      A,@DPTR
   \   000009   22           RET
    170          void outputExecuteBTimeout(struct ep_info_t *ep);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    171          void outputExecuteBTimeout(struct ep_info_t *ep)
   \                     outputExecuteBTimeout:
    172          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
    173              uint8 value = P1 >> 4;
   \   00000E   E590         MOV       A,0x90
   \   000010   C4           SWAP      A
   \   000011   540F         ANL       A,#0xf
   \   000013   85..82       MOV       DPL,?XSP + 0
   \   000016   85..83       MOV       DPH,?XSP + 1
   \   000019   F0           MOVX      @DPTR,A
    174              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
   \   00001A                ; Setup parameters for call to function SendData
   \   00001A   75..01       MOV       ?V0,#0x1
   \   00001D   78..         MOV       R0,#?V0
   \   00001F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000022   78..         MOV       R0,#?V0
   \   000024   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000027   7C00         MOV       R4,#0x0
   \   000029   7D00         MOV       R5,#0x0
   \   00002B   7402         MOV       A,#0x2
   \   00002D   12....       LCALL     ?XSTACK_DISP101_8
   \   000030   EE           MOV       A,R6
   \   000031   240B         ADD       A,#0xb
   \   000033   F582         MOV       DPL,A
   \   000035   E4           CLR       A
   \   000036   3F           ADDC      A,R7
   \   000037   F583         MOV       DPH,A
   \   000039   E0           MOVX      A,@DPTR
   \   00003A   F9           MOV       R1,A
   \   00003B   12....       LCALL     `??SendData::?relay`; Banked call to: SendData
   \   00003E   7402         MOV       A,#0x2
   \   000040   12....       LCALL     ?DEALLOC_XSTACK8
    175          }
   \   000043   7401         MOV       A,#0x1
   \   000045   12....       LCALL     ?DEALLOC_XSTACK8
   \   000048   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   00004B                REQUIRE _A_P1
    176          #endif
    177          /********************************/
    178          /* 温度传感器                   */
    179          /********************************/
    180          #if defined(TEMP_NODE) || defined(HUMM_NODE)
    181          #include "sht10.h"
    182          static uint16 TempValue = 0;
    183          #endif
    184          #if defined(TEMP_NODE)
    185          void sensorTempResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    186          void sensorTempResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    187          {
    188              if(type == ResInit)
    189              {
    190                  SHT10_init(0x01);
    191              }
    192          }
    193          void sensorTempTimeout(struct ep_info_t *ep);
    194          void sensorTempTimeout(struct ep_info_t *ep)
    195          {
    196              unsigned int value = 0;
    197              unsigned char checksum = 0;
    198              SHT10_Measure(&value,&checksum, TEMPERATURE);
    199              TempValue = (value << 2) - 3960;
    200              SendData(ep->ep, &TempValue, 0x0000, TRANSFER_ENDPOINT, sizeof(TempValue));
    201          }
    202          #endif
    203          /********************************/
    204          /* 湿度传感器                   */
    205          /********************************/
    206          #if defined(HUMM_NODE)
    207          void sensorHummResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    208          void sensorHummResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    209          {
    210              if(type == ResInit)
    211              {
    212                  SHT10_init(0x01);
    213              }
    214          }
    215          void sensorHummTimeout(struct ep_info_t *ep);
    216          void sensorHummTimeout(struct ep_info_t *ep)
    217          {
    218              const float C1 = -4.0f;              // for 8 Bit
    219              const float C2 = +0.648f;            // for 8 Bit
    220              const float C3 = -0.0000072f;        // for 8 Bit
    221              const float T1 = 0.01f;              // for 8 bit
    222              const float T2 = 0.00128f;           // for 8 bit
    223              float rh_lin    =   0.0f;                     // rh_lin: Humidity linear
    224              float rh_true   =   0.0f;                    // rh_true: Temperature compensated humidity
    225              float t_C   = 0.0f;                        // t_C   : Temperature []
    226          
    227              unsigned int HumiValue = 0;
    228              unsigned char checksum = 0;
    229              SHT10_Measure(&HumiValue,&checksum, HUMIDITY);
    230              rh_lin=C3*HumiValue*HumiValue + C2*HumiValue + C1;     //calc. humidity from ticks to [%RH]
    231              rh_true=(t_C-25)*(T1+T2*HumiValue)+rh_lin;   //calc. temperature compensated humidity [%RH]
    232              if(rh_true>100)
    233                  rh_true=100;       //cut if the value is outside of
    234              if(rh_true<0.1)
    235                  rh_true=0.1f;       //the physical possible range
    236              HumiValue = (unsigned int)(rh_true * 100);
    237              SendData(ep->ep, &HumiValue, 0x0000, TRANSFER_ENDPOINT, sizeof(HumiValue));
    238          }
    239          #endif
    240          #endif
    241          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    242          struct ep_info_t funcList[] = {
   \                     funcList:
   \   000000                DS 33
   \   000021                REQUIRE `?<Initializer for funcList>`
   \   000021                REQUIRE __INIT_XDATA_I
    243          #if defined(ZDO_COORDINATOR)
    244              {
    245                  roomPwrManSys_StaChgRt,
    246                  roomPwrManSys_IncmRt,
    247                  roomPwrManSys_ToRt,
    248                  roomPwrManSys_ResAvbRt,
    249                  { DevPwrmanSys, 0, 3 },
    250              },
    251          #else
    252          # if defined(IRPERS_NODE)
    253              {
    254                  NULL, NULL, sensorILLumTimeout, sensorIRPersResAvailable,
    255                  { DevIRPers, 0, 2 },                // type, id, refresh cycle
    256              },
    257          # elif defined(ILLUM_NODE)
    258              {
    259                  NULL, NULL, sensorILLumTimeout, NULL,
    260                  { DevIllum, 0, 5 },                // type, id, refresh cycle
    261              },
    262          # elif defined(EXECUTER_NODE)
    263              {
    264                  NULL, outputExecuteB, outputExecuteBTimeout, OutputExecuteBResAvailable,
    265                  { DevExecuter, 0, 7 },              // type, id, refresh cycle
    266              },
    267          #elif defined(TEMP_NODE)
    268              {
    269                  NULL, NULL, sensorTempTimeout, sensorTempResAvailable,
    270                  { DevTemp, 1, 5 },                 // type, id, refresh cycle
    271              },
    272          #elif defined(HUMM_NODE)
    273              {
    274                  NULL, NULL, sensorHummTimeout, sensorHummResAvailable,
    275                  { DevHumm, 0, 5 },                 // type, id, refresh cycle
    276              },
    277          # else
    278          #  error You must define one device
    279          # endif
    280          #endif
    281          };
    282          
    283          // 不能修改下面的内容!!!

   \                                 In  segment XDATA_ROM_C, align 1
    284          const uint8 funcCount = sizeof(funcList) / sizeof(funcList[0]);
   \                     funcCount:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for funcList>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??outputExecuteB::?relay`
   \   000004   ....         DW `??outputExecuteBTimeout::?relay`
   \   000006   ....         DW `??OutputExecuteBResAvailable::?relay`
   \   000008   02           DB 2
   \   000009   00           DB 0
   \   00000A   07           DB 7
   \   00000B   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000013   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001B   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      9   OutputExecuteBResAvailable
        0      9   -> HalIOSetLevel
        0      9   -> HalIOSetOutput
      0     15   outputExecuteB
        0     11   -> HalIOSetLevel
        0     13   -> SendData
      1     12   outputExecuteBTimeout
        0     12   -> SendData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      33  ?<Initializer for funcList>
       5  ?Subroutine0
      13  ?Subroutine1
      10  ?Subroutine2
      76  OutputExecuteBResAvailable
       1  _A_P1
       1  funcCount
      33  funcList
     121  outputExecuteB
      75  outputExecuteBTimeout
      18  -- Other

 
 300 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
  33 bytes in segment XDATA_I
  33 bytes in segment XDATA_ID
   1 byte  in segment XDATA_ROM_C
 
  51 bytes of CODE     memory
   1 byte  of CONST    memory
   0 bytes of DATA     memory (+ 1 byte shared)
 300 bytes of HUGECODE memory
  33 bytes of XDATA    memory

Errors: none
Warnings: none
